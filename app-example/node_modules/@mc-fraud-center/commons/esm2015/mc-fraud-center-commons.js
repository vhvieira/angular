import { Component, ViewChild, Input, Output, forwardRef, EventEmitter, ChangeDetectionStrategy, Inject, Injectable, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import * as momentNS from 'moment';
import { TranslateService, TranslateModule } from '@ngx-translate/core';
import { Logger, MessageService, LocaleService, trackByIndex, MastercardCommons } from '@mastercard/ng-commons';
import { tap } from 'rxjs/operators/tap';
import { ModalDirective, AccordionModule, AlertModule, ButtonsModule, CarouselModule, CollapseModule, ModalModule, BsDropdownModule, PaginationModule, ProgressbarModule, RatingModule, SortableModule, TabsModule, TimepickerModule, TooltipModule, TypeaheadModule, PopoverModule } from 'ngx-bootstrap';
import { Subject } from 'rxjs/Subject';
import { ToastrService, ToastrModule } from 'ngx-toastr';
import { __decorate, __metadata } from 'tslib';
import { deserialize, deserializeAs, Serialize, Deserialize } from 'cerialize';
import { Http, Response, Headers, RequestOptions, XSRFStrategy, CookieXSRFStrategy } from '@angular/http';
import { isEqual, pickBy } from 'lodash';
import { _throw } from 'rxjs/observable/throw';
import { of } from 'rxjs/observable/of';
import { mergeMap, tap as tap$1, catchError, shareReplay, map, mergeMapTo, finalize, filter, publishReplay, refCount } from 'rxjs/operators';
import { filter as filter$1 } from 'rxjs/operators/filter';
import { map as map$1 } from 'rxjs/operators/map';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment = momentNS;
class DatePickerComponent {
    /**
     * @param {?} translateService
     * @param {?} logger
     */
    constructor(translateService, logger) {
        this.translateService = translateService;
        this.logger = logger;
        this.format = 'MMM D, Y';
        this.additionalFormats = ['M/D/YYYY'];
        this.allowInvalid = false;
        this.allowEdit = true;
        this.customClassNames = '';
        this.changed = new EventEmitter();
        this.open = false;
        this.openTimepicker = false;
        this.disabled = false;
        this.propagateChange = (_) => {
            // do nothing
        };
        this.writeValue = (v) => {
            if (v) {
                if (v === this.componentValue) {
                    return;
                }
                else if (v && v instanceof Date) {
                    const /** @type {?} */ d = moment(v);
                    this.milliseconds = d.millisecond();
                    this.seconds = d.second();
                    this.minutes = d.minute();
                    this.hours = d.hour();
                    this._updateValue(v);
                }
            }
            else {
                this._updateValue(null);
            }
        };
        this.x = this.y = this.z = 0;
        this.open = false;
        this.lang = this.lang || this.translateService.currentLang;
        moment.locale('en-US');
        if (this.lang === 'en-US') {
            moment.locale(this.lang);
        }
        else if (this.lang === 'pt-BR') {
            moment.locale(this.lang);
        }
        else if (this.lang === 'es-CO') {
            moment.locale(this.lang);
        }
        else {
            try {
                moment.locale(this.lang);
            }
            catch (/** @type {?} */ e) {
                this.logger.error('Locale ERROR: Locale not recognized.');
            }
        }
        this.datepickerClasses = this.getClasses();
        this.rowCounts = this.rowCount();
        this.daysOfWeek = {
            'en-US': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            'es-CO': ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'],
            'pt-BR': ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb']
        };
        this.monthOfYear = {
            'en-US': [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December'
            ],
            'es-CO': ['Enero',
                'Febrero',
                'Marzo',
                'Abril',
                'Mayo',
                'Junio',
                'Julio',
                'Agosto',
                'Septiembre',
                'Octubre',
                'Noviembre',
                'Diciembre'],
            'pt-BR': ['Janeiro',
                'Fevereiro',
                'Março',
                'Abril',
                'Maio',
                'Junho',
                'Julho',
                'Agosto',
                'Setembro',
                'Outubro',
                'Novembro',
                'Dezembro']
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.display = '';
        this.displayValue = moment().format(this.format);
        // This is to initialise the start date display value with current system date
    }
    /**
     * @return {?}
     */
    getInputClasses() {
        const /** @type {?} */ classes = [];
        classes.push(this.customClassNames);
        if (this.open) {
            classes.push('date-picker-popup-open');
        }
        return classes.join(' ');
    }
    /**
     * @return {?}
     */
    getClasses() {
        const /** @type {?} */ classes = {
            'datepicker datepicker-dropdown': true,
            'dropdown-menu': true
        };
        switch (this.orient) {
            case 'bottom-left':
            default:
                classes['datepicker-orient-left'] = true;
                classes['datepicker-orient-bottom'] = true;
                break;
            case 'bottom-right':
                classes['datepicker-orient-right'] = true;
                classes['datepicker-orient-bottom'] = true;
                break;
            case 'top-left':
                classes['datepicker-orient-left'] = true;
                classes['datepicker-orient-top'] = true;
                break;
            case 'top-right':
                classes['datepicker-orient-right'] = true;
                classes['datepicker-orient-top'] = true;
                break;
        }
        return classes;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClick($event) {
        if (!this.open) {
            const /** @type {?} */ el = $event.srcElement || $event.target;
            switch (this.orient) {
                case 'bottom-left':
                default:
                    this.x = el.offsetLeft;
                    this.y = el.offsetTop + el.offsetHeight + 4;
                    break;
                case 'bottom-right':
                    this.x = el.offsetLeft + el.offsetWidth - 10;
                    this.y = el.offsetTop + el.offsetHeight + 4;
                    break;
                case 'top-left':
                    this.x = el.offsetLeft;
                    this.y = el.offsetTop - 4;
                    break;
                case 'top-right':
                    this.x = el.offsetLeft + el.offsetWidth - 10;
                    this.y = el.offsetTop - 4;
                    break;
            }
            this.x = `${this.x}px`;
            this.y = `${this.y}px`;
            this.z = 10;
            this.display = 'block';
            this.open = true;
            this.calDate = moment(this.curDate);
            el.blur();
        }
        //   $event.stopPropagation();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    eatClick($event) {
        $event.stopPropagation();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDeClick($event) {
        if ($event && ($event.target === this.input.nativeElement)) {
            return;
        }
        if (this.open) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.display = 'none';
            this.open = false;
        }
    }
    /**
     * @param {?} dt
     * @return {?}
     */
    onDayClick(dt) {
        if (!dt.classes.disabled) {
            this._updateValue(dt.date);
            this.onDeClick(null);
        }
        this.openTimepicker = true;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onInputChange($event) {
        const /** @type {?} */ value = moment($event.target.value, [this.format].concat(this.additionalFormats), true);
        if (this._validate(value)) {
            this._updateValue(value.toDate());
        }
        else {
            this._updateValue(null);
        }
    }
    /**
     * @return {?}
     */
    displayMonth() {
        this._calDate();
        return `${this.monthOfYear[this.lang][this.calDate.month()]} ${this.calDate.year()}`;
    }
    /**
     * @return {?}
     */
    rowCount() {
        let /** @type {?} */ first;
        let /** @type {?} */ last;
        const /** @type {?} */ rows = [];
        this._calDate();
        first = this._first(this.calDate);
        first.startOf('week');
        last = moment(this.calDate);
        last.endOf('month').endOf('week');
        for (let /** @type {?} */ i = 0; i <= last.diff(first, 'weeks'); i++) {
            rows.push(i);
        }
        return rows;
    }
    /**
     * @param {?} row
     * @return {?}
     */
    calendarRow(row) {
        let /** @type {?} */ first;
        let /** @type {?} */ last;
        let /** @type {?} */ start;
        let /** @type {?} */ highlight;
        const /** @type {?} */ today = moment().startOf('day');
        const /** @type {?} */ cols = [];
        first = this._first(this.calDate);
        last = this._last(this.calDate);
        start = this._start(first, row);
        highlight = this.curDate && moment(this.curDate).startOf('day');
        for (let /** @type {?} */ i = 0; i < 7; i++) {
            cols.push({
                value: start.date(),
                date: start.toDate(),
                classes: {
                    day: true,
                    old: start.diff(first, 'days') < 0,
                    new: start.diff(last, 'days') > 0,
                    highlighted: 0 === start.diff(highlight, 'days'),
                    today: 0 === start.diff(today, 'days'),
                    active: 0 === start.diff(highlight, 'days'),
                    disabled: this._disabled(start.toDate())
                }
            });
            start.add(1, 'days');
        }
        return cols;
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    registerOnChange(cb) {
        this.propagateChange = cb;
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    registerOnTouched(cb) {
        this.onTouched = cb;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisabledState(disabled) {
        if (disabled) {
            this.onDeClick(null);
        }
        this.disabled = disabled;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    _updateValue(v) {
        this.componentValue = this._normalizeTime(v);
        this.curDate = this.componentValue && moment(this.componentValue);
        this._formatDisplay();
        // this.model.viewToModelUpdate(this.componentValue || '');
        this.changed.emit(this.componentValue || '');
        this.propagateChange(this.componentValue || '');
    }
    /**
     * @return {?}
     */
    _formatDisplay() {
        let /** @type {?} */ v;
        if (this.curDate && this.curDate.isValid()) {
            v = this.curDate.format(this.format);
        }
        else if (this.allowInvalid) {
            v = this.input.nativeElement.value;
        }
        else {
            v = '';
        }
        if (v === this.displayValue) {
            this.input.nativeElement.value = v;
        }
        else {
            this.displayValue = v;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    _first(date) {
        return moment(date).startOf('month').startOf('day');
    }
    /**
     * @param {?} date
     * @return {?}
     */
    _last(date) {
        return moment(date).endOf('month').startOf('day');
    }
    /**
     * @param {?} date
     * @param {?} row
     * @return {?}
     */
    _start(date, row) {
        return moment(date).startOf('week').startOf('day').add(7 * row, 'days');
    }
    /**
     * @param {?} date
     * @return {?}
     */
    _validate(date) {
        if (this.allowInvalid) {
            return true;
        }
        else if (date.isValid()) {
            if (!this.min || date.toDate() >= this.min) {
                if (!this.max || date.toDate() <= this.max) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * @param {?} dt
     * @return {?}
     */
    _disabled(dt) {
        const /** @type {?} */ d = this._normalizeTime(dt);
        if (this.min && d < this.min) {
            return true;
        }
        else if (this.max && d > this.max) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} dt
     * @return {?}
     */
    _normalizeTime(dt) {
        let /** @type {?} */ d;
        if (!dt) {
            return dt;
        }
        d = moment(dt);
        d.millisecond(this.milliseconds);
        d.second(this.seconds);
        d.minute(this.minutes);
        d.hour(this.hours);
        return d.toDate();
    }
    /**
     * @return {?}
     */
    _calDate() {
        this.calDate = moment(this.calDate || this.curDate);
        if (!this.calDate.isValid()) {
            this.calDate = moment();
        }
    }
    /**
     * @param {?} i
     * @return {?}
     */
    trackByFn(i) {
        return i;
    }
}
DatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'fc-date-picker',
                template: `<input #input id="date-picker-input" type="text" [value]="displayValue" class="form-control input-standard icon-calendar "  [ngClass]="getInputClasses()"
	   (click)="onClick ($event)" (window:click)="onDeClick ($event)" (change)="onInputChange ($event)" (blur)="onTouched()"
	   [disabled]="disabled" [readonly]="!allowEdit">
<div [ngClass]="datepickerClasses" [style.top]="y" [style.left]="x" [style.z-index]="z" [style.display]="display" (click)="eatClick ($event)">
	<div class="datepicker-days">
		<table class="table-condensed">
			<thead>
				<tr>
					<th colspan="7" class="datepicker-title" [style.display]="title ? 'table-cell' : 'none'">{{ title }}</th>
				</tr>
				<tr>
					<th class="prevYear" (click)="calDate.subtract (1, 'year')"><i class="fa fa-angle-double-left color-orange" aria-hidden="true"></i></th>
					<th class="prev" (click)="calDate.subtract (1, 'month')"><i class="fa fa-angle-left color-orange" aria-hidden="true"></i></th>
					<th colspan="3" class="datepicker-switch">{{ displayMonth () }}</th>
					<th class="next" (click)="calDate.add (1, 'month')"><i class="fa fa-angle-right color-orange" aria-hidden="true"></i></th>
					<th class="nextYear" (click)="calDate.add (1, 'year')"><i class="fa fa-angle-double-right color-orange" aria-hidden="true"></i></th>
				</tr>
				<tr>
					<th *ngFor="let day of daysOfWeek[lang]; trackBy: trackByFn" class="dow">{{ day }}</th>
				</tr>
			</thead>
			<tbody>
				<tr *ngFor="let row of rowCount(); trackBy: trackByFn">
					<td *ngFor="let day of calendarRow(row); trackBy: trackByFn" [ngClass]="day.classes" (click)="onDayClick (day)">{{ day.value }}</td>
				</tr>
			</tbody>
		</table>
	</div>
</div>
`,
                styles: [`.icon-calendar{
  background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOC4xLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjI1LjNweCINCgkgaGVpZ2h0PSIyNC45cHgiIHZpZXdCb3g9IjAgMCAyNS4zIDI0LjkiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI1LjMgMjQuOSIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8ZyBpZD0iY2FsIj4NCgk8Zz4NCgkJPHBhdGggZmlsbD0iI0NDQ0NDQyIgZD0iTTIwLjksNGgxLjhjMC41LDAsMC45LDAuMiwxLjMsMC41YzAuNCwwLjMsMC41LDAuNywwLjUsMS4ydjE3YzAsMC41LTAuMiwwLjktMC41LDEuMg0KCQkJYy0wLjQsMC4zLTAuOCwwLjUtMS4zLDAuNUgyLjVjLTAuNSwwLTAuOS0wLjItMS4zLTAuNWMtMC40LTAuMy0wLjUtMC43LTAuNS0xLjJ2LTE3YzAtMC41LDAuMi0wLjksMC41LTEuMkMxLjUsNC4yLDIsNCwyLjUsNGgxLjgNCgkJCSBNMi41LDIyLjhoMjAuM1Y5LjFIMi41VjIyLjh6Ii8+DQoJCTxyZWN0IHg9IjYiIHk9IjExIiBmaWxsPSIjQ0NDQ0NDIiB3aWR0aD0iMi41IiBoZWlnaHQ9IjIuNSIvPg0KCQk8cmVjdCB4PSIxNS4zIiB5PSIwLjUiIGZpbGw9IiNDQ0NDQ0MiIHdpZHRoPSIzLjgiIGhlaWdodD0iNS45Ii8+DQoJCTxyZWN0IHg9IjYuMSIgeT0iMC41IiBmaWxsPSIjQ0NDQ0NDIiB3aWR0aD0iMy44IiBoZWlnaHQ9IjUuOSIvPg0KCQk8cmVjdCB4PSIxMS4xIiB5PSIxMSIgZmlsbD0iI0NDQ0NDQyIgd2lkdGg9IjIuNSIgaGVpZ2h0PSIyLjUiLz4NCgkJPHJlY3QgeD0iMTYuMyIgeT0iMTEiIGZpbGw9IiNDQ0NDQ0MiIHdpZHRoPSIyLjUiIGhlaWdodD0iMi41Ii8+DQoJPC9nPg0KPC9nPg0KPGcgaWQ9ImNhbC1vdmVyIiBkaXNwbGF5PSJub25lIj4NCgk8ZyBkaXNwbGF5PSJpbmxpbmUiPg0KCQk8cGF0aCBmaWxsPSIjOEY4RjhGIiBkPSJNMjAuOSw0aDEuOGMwLjUsMCwwLjksMC4yLDEuMywwLjVjMC40LDAuMywwLjUsMC43LDAuNSwxLjJ2MTdjMCwwLjUtMC4yLDAuOS0wLjUsMS4yDQoJCQljLTAuNCwwLjMtMC44LDAuNS0xLjMsMC41SDIuNWMtMC41LDAtMC45LTAuMi0xLjMtMC41Yy0wLjQtMC4zLTAuNS0wLjctMC41LTEuMnYtMTdjMC0wLjUsMC4yLTAuOSwwLjUtMS4yQzEuNSw0LjIsMiw0LDIuNSw0aDEuOA0KCQkJIE0yLjUsMjIuOGgyMC4zVjkuMUgyLjVWMjIuOHoiLz4NCgkJPHJlY3QgeD0iNiIgeT0iMTEiIGZpbGw9IiM4RjhGOEYiIHdpZHRoPSIyLjUiIGhlaWdodD0iMi41Ii8+DQoJCTxyZWN0IHg9IjE1LjMiIHk9IjAuNSIgZmlsbD0iIzhGOEY4RiIgd2lkdGg9IjMuOCIgaGVpZ2h0PSI1LjkiLz4NCgkJPHJlY3QgeD0iNi4xIiB5PSIwLjUiIGZpbGw9IiM4RjhGOEYiIHdpZHRoPSIzLjgiIGhlaWdodD0iNS45Ii8+DQoJCTxyZWN0IHg9IjExLjEiIHk9IjExIiBmaWxsPSIjOEY4RjhGIiB3aWR0aD0iMi41IiBoZWlnaHQ9IjIuNSIvPg0KCQk8cmVjdCB4PSIxNi4zIiB5PSIxMSIgZmlsbD0iIzhGOEY4RiIgd2lkdGg9IjIuNSIgaGVpZ2h0PSIyLjUiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==);
  background-position:right 6px center;
  background-repeat:no-repeat;
  min-height:44px;
  min-width:32px;
  background-color:white; }
.icon-calendar:hover{
  background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOC4xLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjI1LjNweCINCgkgaGVpZ2h0PSIyNC45cHgiIHZpZXdCb3g9IjAgMCAyNS4zIDI0LjkiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI1LjMgMjQuOSIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8ZyBpZD0iY2FsIiBkaXNwbGF5PSJub25lIj4NCgk8ZyBkaXNwbGF5PSJpbmxpbmUiPg0KCQk8cGF0aCBmaWxsPSIjQ0NDQ0NDIiBkPSJNMjAuOSw0aDEuOGMwLjUsMCwwLjksMC4yLDEuMywwLjVjMC40LDAuMywwLjUsMC43LDAuNSwxLjJ2MTdjMCwwLjUtMC4yLDAuOS0wLjUsMS4yDQoJCQljLTAuNCwwLjMtMC44LDAuNS0xLjMsMC41SDIuNWMtMC41LDAtMC45LTAuMi0xLjMtMC41Yy0wLjQtMC4zLTAuNS0wLjctMC41LTEuMnYtMTdjMC0wLjUsMC4yLTAuOSwwLjUtMS4yQzEuNSw0LjIsMiw0LDIuNSw0aDEuOA0KCQkJIE0yLjUsMjIuOGgyMC4zVjkuMUgyLjVWMjIuOHoiLz4NCgkJPHJlY3QgeD0iNiIgeT0iMTEiIGZpbGw9IiNDQ0NDQ0MiIHdpZHRoPSIyLjUiIGhlaWdodD0iMi41Ii8+DQoJCTxyZWN0IHg9IjE1LjMiIHk9IjAuNSIgZmlsbD0iI0NDQ0NDQyIgd2lkdGg9IjMuOCIgaGVpZ2h0PSI1LjkiLz4NCgkJPHJlY3QgeD0iNi4xIiB5PSIwLjUiIGZpbGw9IiNDQ0NDQ0MiIHdpZHRoPSIzLjgiIGhlaWdodD0iNS45Ii8+DQoJCTxyZWN0IHg9IjExLjEiIHk9IjExIiBmaWxsPSIjQ0NDQ0NDIiB3aWR0aD0iMi41IiBoZWlnaHQ9IjIuNSIvPg0KCQk8cmVjdCB4PSIxNi4zIiB5PSIxMSIgZmlsbD0iI0NDQ0NDQyIgd2lkdGg9IjIuNSIgaGVpZ2h0PSIyLjUiLz4NCgk8L2c+DQo8L2c+DQo8ZyBpZD0iY2FsLW92ZXIiPg0KCTxnPg0KCQk8cGF0aCBmaWxsPSIjOEY4RjhGIiBkPSJNMjAuOSw0aDEuOGMwLjUsMCwwLjksMC4yLDEuMywwLjVjMC40LDAuMywwLjUsMC43LDAuNSwxLjJ2MTdjMCwwLjUtMC4yLDAuOS0wLjUsMS4yDQoJCQljLTAuNCwwLjMtMC44LDAuNS0xLjMsMC41SDIuNWMtMC41LDAtMC45LTAuMi0xLjMtMC41Yy0wLjQtMC4zLTAuNS0wLjctMC41LTEuMnYtMTdjMC0wLjUsMC4yLTAuOSwwLjUtMS4yQzEuNSw0LjIsMiw0LDIuNSw0aDEuOA0KCQkJIE0yLjUsMjIuOGgyMC4zVjkuMUgyLjVWMjIuOHoiLz4NCgkJPHJlY3QgeD0iNiIgeT0iMTEiIGZpbGw9IiM4RjhGOEYiIHdpZHRoPSIyLjUiIGhlaWdodD0iMi41Ii8+DQoJCTxyZWN0IHg9IjE1LjMiIHk9IjAuNSIgZmlsbD0iIzhGOEY4RiIgd2lkdGg9IjMuOCIgaGVpZ2h0PSI1LjkiLz4NCgkJPHJlY3QgeD0iNi4xIiB5PSIwLjUiIGZpbGw9IiM4RjhGOEYiIHdpZHRoPSIzLjgiIGhlaWdodD0iNS45Ii8+DQoJCTxyZWN0IHg9IjExLjEiIHk9IjExIiBmaWxsPSIjOEY4RjhGIiB3aWR0aD0iMi41IiBoZWlnaHQ9IjIuNSIvPg0KCQk8cmVjdCB4PSIxNi4zIiB5PSIxMSIgZmlsbD0iIzhGOEY4RiIgd2lkdGg9IjIuNSIgaGVpZ2h0PSIyLjUiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==);
  background-position:right 6px center;
  background-repeat:no-repeat;
  min-height:44px;
  min-width:32px;
  cursor:pointer;
  background-color:white; }
.datepicker table tr td.new,
.datepicker table tr td.old{
  visibility:hidden; }
.datepicker table tr td.disabled{
  color:#C3C3C3; }
.datepicker th.dow{
  text-transform:uppercase; }
.datepicker table{
  border-collapse:collapse; }
.datepicker table tr td.day{
  cursor:pointer; }
.datepicker table tr td.old.day{
  border:0; }
.datepicker table tr td.highlighted{
  background-color:#F9F9F9; }
.datepicker table tr td.day.focused{
  border:1px solid #008E96;
  background-color:#FFF; }
.datepicker table tr td.today{
  background-color:#FFF;
  background-image:none;
  border:2px solid #378F7B; }
.datepicker table tr td.active, .datepicker table tr td.active.active,
.datepicker table tr td.active:hover:hover{
  background-image:none; }
.datepicker th.dow{
  color:#008E96;
  font-weight:400; }
@media (min-width: 768px){
  .datepicker th.dow{
    min-width:42px; }
  .datepicker tbody td, .datepicker tbody th{
    width:44px;
    height:44px; } }
.datepicker tbody td, .datepicker tbody th{
  border:1px solid #F0EDE9;
  border-radius:0;
  background-color:#FFF;
  text-align:center; }
.datepicker .next, .datepicker .prev, .datepicker .nextYear, .datepicker .prevYear{
  color:#e87600;
  cursor:pointer; }
@media (max-width: 480px){
  .datepicker{
    font-size:12px; } }
.datepicker-dropdown.datepicker-orient-top:after{
  bottom:-6px;
  border-bottom:0;
  border-top:6px solid #FFF; }
.datepicker-dropdown.datepicker-orient-top:before{
  bottom:-7px;
  border-bottom:0;
  border-top:7px solid #999; }
.datepicker-dropdown:after, .datepicker-dropdown:before{
  content:'';
  display:inline-block;
  border-top:0;
  position:absolute; }
.datepicker-dropdown.datepicker-orient-bottom:before{
  top:-7px; }
.datepicker-dropdown.datepicker-orient-left:before{
  left:6px; }
.datepicker-dropdown:before{
  border-left:7px solid transparent;
  border-right:7px solid transparent;
  border-bottom:7px solid rgba(0, 0, 0, 0.15);
  border-bottom-color:rgba(0, 0, 0, 0.2); }
.datepicker-dropdown.datepicker-orient-bottom:after{
  top:-6px; }
.datepicker-dropdown.datepicker-orient-left:after{
  left:7px; }
.datepicker-dropdown:after{
  border-left:6px solid transparent;
  border-right:6px solid transparent;
  border-bottom:6px solid #FFF; }
.datepicker .next, .datepicker .prev, .datepicker .nextYear, .datepicker .prevYear, .datepicker-switch{
  text-align:center; }
.datepicker-days{
  margin:0 5px; }
input#date-picker-input.date-picker-popup-open{
  border-color:#ccc;
  background-color:white; }
input{
  font-family:Markoffc;
  min-height:44px; }
.datepicker table tr td.active.active,
.datepicker table tr td.active.highlighted.active,
.datepicker table tr td.active.highlighted:active,
.datepicker table tr td.active:active{
  color:#333;
  text-shadow:none; }
.datepicker table tr td.active.highlighted:hover,
.datepicker table tr td.day:hover,
table tr td.active.highlighted{
  border:2px solid #378F7B; }
`],
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => DatePickerComponent),
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
DatePickerComponent.ctorParameters = () => [
    { type: TranslateService, },
    { type: Logger, },
];
DatePickerComponent.propDecorators = {
    "orient": [{ type: Input },],
    "title": [{ type: Input },],
    "lang": [{ type: Input },],
    "format": [{ type: Input },],
    "additionalFormats": [{ type: Input },],
    "min": [{ type: Input },],
    "max": [{ type: Input },],
    "allowInvalid": [{ type: Input },],
    "allowEdit": [{ type: Input },],
    "customClassNames": [{ type: Input },],
    "changed": [{ type: Output },],
    "input": [{ type: ViewChild, args: ['input',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This component displays a button that triggers a download stream.
 *
 * ### Example:
 * ```html
 * <mc-download-button
 *   label="TCC_LIMITS.LABELS.EXPORT"
 *   filename="StandIn TCC Limits.xlsx"
 *   [disabled]="! records.length"
 *   (download)="onExport()"
 * ></mc-download-button>
 * ```
 *
 * ```ts
 *
 * // parent.component.ts
 *
 * // \@ViewChild(DownloadButtonComponent) exportButton: DownloadButtonComponent;
 *
 * onExport() {
 *   const stream: Observable<HttpResponse<any>> = this.service.exportFile();
 *   this.exportButton.save(stream).subscribe(
 *     () => console.log('export done'),
 *     err => console.error('export error', err),
 *   );
 * }
 * ```
 */
class DownloadButtonComponent {
    /**
     * @param {?} window
     */
    constructor(window) {
        /**
         * Enables / disables the button
         */
        this.disabled = false;
        /**
         * The file will be downloaded with this name. Defaults to "downloaded.txt"
         */
        this.filename = 'downloaded.txt';
        /**
         * Button's label (key for translation)
         */
        this.label = 'Download';
        /**
         * Emits when the button is clicked
         */
        this.download = new EventEmitter();
        this.window = window;
    }
    /**
     * Handler to the button.
     * @return {?}
     */
    onDownload() {
        this.download.emit();
    }
    /**
     * Triggers the file download.
     * @param {?} download$ endpoint's stream
     * @return {?}
     */
    save(download$) {
        return download$.pipe(tap(res => {
            const /** @type {?} */ data = new this.window.Blob([res.response.arrayBuffer()]);
            if (this.window.navigator.msSaveOrOpenBlob) {
                this.window.navigator.msSaveOrOpenBlob(data, this.filename);
            }
            else {
                const /** @type {?} */ url = this.window.URL.createObjectURL(data);
                this.downloadAnchor.nativeElement.href = url;
                this.downloadAnchor.nativeElement.click();
                setTimeout(() => this.window.URL.revokeObjectURL(url));
            }
        }));
    }
}
DownloadButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'fc-download-button',
                template: `<button type="button" class="btn secondary"
  [disabled]="disabled"
  (click)="onDownload()"
>
  {{ label }}
  <i class="fa fa-download"></i>
</button>
<a #downloadAnchor href="" [download]="filename" hidden ></a>
`
            },] },
];
/** @nocollapse */
DownloadButtonComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
];
DownloadButtonComponent.propDecorators = {
    "disabled": [{ type: Input },],
    "filename": [{ type: Input },],
    "label": [{ type: Input },],
    "download": [{ type: Output },],
    "downloadAnchor": [{ type: ViewChild, args: ['downloadAnchor',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DownloadMessages = Object.freeze({
    WAIT: 'ACTION.DOWNLOAD.WAIT',
    SUCCESS: 'ACTION.DOWNLOAD.SUCCESS',
    ERROR: 'ACTION.DOWNLOAD.ERROR',
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FcDialogComponent {
    /**
     * @param {?} logger
     */
    constructor(logger) {
        this.logger = logger;
        this.labelDialog = 'CONFIRMATION_DIALOG.HEADER';
        this.labelSecondaryButton = 'CONFIRMATION_DIALOG.CANCEL';
        this.labelPrimaryButton = 'CONFIRMATION_DIALOG.OK';
        this.buttonClick = new EventEmitter();
        this.enableSecondaryButton = true;
        this.config = {
            backdrop: 'static',
            show: false,
            keyboard: false,
        };
    }
    /**
     * @return {?}
     */
    show() {
        this.logger.debug('Showing confirmation modal');
        this.modal.show();
    }
    /**
     * @return {?}
     */
    onSecondaryButton() {
        this.logger.debug('Secondary button clicked');
        this.buttonClick.emit(true);
        this.modal.hide();
    }
    /**
     * @return {?}
     */
    onPrimaryButton() {
        this.logger.debug('Primary button clicked');
        this.buttonClick.emit(false);
        this.modal.hide();
    }
    /**
     * @return {?}
     */
    checkTitle() {
        return this.titleDialog != null;
    }
}
FcDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'fc-dialog',
                template: `<div bsModal [config]="config" class="modal" tabindex="-1" role="dialog">
  <div class="modal-dialog fc-dialog modal-sm">
    <div class="modal-content">
      <div class="modal-header" *ngIf="checkTitle()">
        <div class="confirmation-dialog-title"><h4>{{
          titleDialog | translate
        }}</h4></div>
      </div>
      <div class="modal-body">
        <p [innerHTML]="labelDialog | translate"></p>
      </div>
      <div class="modal-footer">
        <div class="row">
          <div class="col-xs-12">
            <button *ngIf="enableSecondaryButton" id="modalSecondaryButton" type="button" class="btn btn-sm secondary" data-dismiss="modal" (click)="onSecondaryButton()">{{labelSecondaryButton | translate}}</button>
            <button id="modalPrimaryButton" type="button" class="btn btn-sm primary" (click)="onPrimaryButton()">{{labelPrimaryButton | translate}}</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
`,
                styles: [`.fc-dialog{
  padding-top:5px;
  padding-bottom:5px;
  min-height:70px;
  max-width:450px; }
  .fc-dialog .modal-header{
    border-bottom:none;
    padding:24px;
    padding-bottom:0; }
    .fc-dialog .modal-header h4{
      margin:initial; }
  .fc-dialog .modal-body{
    padding:24px;
    font-size:14px;
    text-align:initial; }
    .fc-dialog .modal-body p{
      margin:0;
      padding:0; }
  .fc-dialog .modal-footer{
    padding:24px;
    padding-top:0;
    border-top:none; }
    .fc-dialog .modal-footer .btn{
      margin-bottom:0; }
div.fade{
  -webkit-transition:none !important;
  transition:none !important; }
@media (min-width: 768px){
  .btn.btn-sm.primary, .btn.btn-sm.secondary, .btn.btn-sm.tertiary{
    min-width:90px;
    font-size:12px; } }
`],
            },] },
];
/** @nocollapse */
FcDialogComponent.ctorParameters = () => [
    { type: Logger, },
];
FcDialogComponent.propDecorators = {
    "modal": [{ type: ViewChild, args: [ModalDirective,] },],
    "titleDialog": [{ type: Input },],
    "labelDialog": [{ type: Input },],
    "labelSecondaryButton": [{ type: Input },],
    "labelPrimaryButton": [{ type: Input },],
    "buttonClick": [{ type: Output },],
    "enableSecondaryButton": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This service provides methods for adding/removing messages on the `PleaseWaitComponent`.
 */
class PleaseWaitService {
    constructor() {
        this.messages = [];
        this.change$ = new Subject();
    }
    /**
     * Adds the given message into the "please wait" modal.
     * @param {?} message text to be added into the modal.
     * @return {?}
     */
    add(message) {
        if (this.messages.indexOf(message) > -1) {
            return this.messages.length;
        }
        const /** @type {?} */ size = this.messages.push(message);
        this.emit(this.messages);
        return size;
    }
    /**
     * Removes the given message from the "please wait" modal.
     * @param {?} message text to be removed from the modal.
     * @return {?}
     */
    remove(message) {
        const /** @type {?} */ originalSize = this.messages.length;
        this.messages = this.messages.filter(m => m !== message);
        if (originalSize !== this.messages.length)
            this.emit(this.messages);
        return this.messages.length;
    }
    /**
     * Notifies when a message is added/removed by emitting the whole array of messages.
     * @return {?}
     */
    get messagesChange() {
        return this.change$.asObservable();
    }
    /**
     * @param {?} messages
     * @return {?}
     */
    emit(messages) {
        const /** @type {?} */ clone = messages.slice(0);
        this.change$.next(clone);
    }
}
PleaseWaitService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PleaseWaitService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const Toastr = Object.freeze({
    DEFAULT_TTL: 3000,
    INFO_TITLE: 'NOTIFICATIONS.TITLE.INFO',
    SUCCESS_TITLE: 'NOTIFICATIONS.TITLE.SUCCESS',
    WARNING_TITLE: 'NOTIFICATIONS.TITLE.WARNING',
    ERROR_TITLE: 'NOTIFICATIONS.TITLE.ERROR',
    POST_MESSAGE_KEY: 'SHOW_NOTIFICATION',
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This service provides methods for displaying toast messages
 * (temporary, pop-up messages).
 *
 * There are 4 levels: INFO, SUCCESS, WARNING, ERROR.
 *
 * The service detects if the app is embedded in an iframe. If so,
 * it delivers the toast to the parent (shell) window via `postMessage`.
 * Otherwise, it displays the toast on the current window.
 */
class ToastrService$1 {
    /**
     * @param {?} messageService
     * @param {?} logger
     * @param {?} translate
     * @param {?} ngxToastrService
     * @param {?} window
     */
    constructor(messageService, logger, translate, ngxToastrService, window) {
        this.messageService = messageService;
        this.logger = logger;
        this.translate = translate;
        this.ngxToastrService = ngxToastrService;
        this.window = window;
        if (this.window.self === this.window.top) {
            this.logger.debug('Toastr strategy: native');
            this.send = this.postNative;
        }
        else {
            this.logger.debug('Toastr strategy: shell');
            this.send = this.postToShell;
        }
    }
    /**
     * Toasts an info message.
     * @param {?} message the text to display.
     * @param {?=} title message title.
     * @param {?=} timeToLive in milliseconds.
     * @return {?}
     */
    info(message, title = Toastr.INFO_TITLE, timeToLive = Toastr.DEFAULT_TTL) {
        this.translate.get([title, message])
            .subscribe(keys => this.send(keys[message], keys[title], timeToLive, 'info'));
    }
    /**
     * Toasts a success message.
     * @param {?} message the text to display.
     * @param {?=} title message title.
     * @param {?=} timeToLive in milliseconds.
     * @return {?}
     */
    success(message, title = Toastr.SUCCESS_TITLE, timeToLive = Toastr.DEFAULT_TTL) {
        this.translate.get([title, message])
            .subscribe(keys => this.send(keys[message], keys[title], timeToLive, 'success'));
    }
    /**
     * Toasts a warning message.
     * @param {?} message the text to display.
     * @param {?=} title message title.
     * @param {?=} timeToLive in milliseconds.
     * @return {?}
     */
    warning(message, title = Toastr.WARNING_TITLE, timeToLive = Toastr.DEFAULT_TTL) {
        this.translate.get([title, message])
            .subscribe(keys => this.send(keys[message], keys[title], timeToLive, 'warning'));
    }
    /**
     * Toasts an error message.
     * @param {?} message the text to display.
     * @param {?=} title message title.
     * @param {?=} timeToLive in milliseconds.
     * @return {?}
     */
    error(message, title = Toastr.ERROR_TITLE, timeToLive = Toastr.DEFAULT_TTL) {
        this.translate.get([title, message])
            .subscribe(keys => this.send(keys[message], keys[title], timeToLive, 'error'));
    }
    /**
     * @param {?} message
     * @param {?} title
     * @param {?} timeToLive
     * @param {?} severity
     * @return {?}
     */
    postToShell(message, title, timeToLive, severity) {
        this.messageService.post({
            message: Toastr.POST_MESSAGE_KEY,
            content: { message, title, timeToLive, severity: severity.toUpperCase() },
        });
    }
    /**
     * @param {?} message
     * @param {?} title
     * @param {?} timeOut
     * @param {?} severity
     * @return {?}
     */
    postNative(message, title, timeOut, severity) {
        this.ngxToastrService[severity](message, title, { timeOut });
    }
}
ToastrService$1.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ToastrService$1.ctorParameters = () => [
    { type: MessageService, },
    { type: Logger, },
    { type: TranslateService, },
    { type: ToastrService, },
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class HttpResponse {
    /**
     * @param {?} response
     * @param {?=} data
     */
    constructor(/** The HTTP Response */
        response, /** Deserialized response body */
        data) {
        // empty
        this.response = response;
        this.data = data;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Wraps errors emitted by `HttpService`.
 */
class HttpError extends Error {
    /**
     * @param {?} message
     * @param {?} payload
     * @param {?} displayMessage
     * @param {?=} status
     */
    constructor(message, payload, displayMessage, status) {
        super(message);
        this.message = message;
        this.payload = payload;
        this.displayMessage = displayMessage;
        this.status = status;
        this.name = 'HttpError';
        // otherwise this instanceof HttpError would be false o_O
        Object.setPrototypeOf(this, HttpError.prototype);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const HttpDisplayMessages = Object.freeze({
    OK: 'ACTION.SUCCESS',
    ERROR: 'ACTION.ERROR',
    401: 'HTTP.STATUS.401',
    403: 'HTTP.STATUS.403',
    404: 'HTTP.STATUS.404',
    500: 'HTTP.STATUS.500',
    503: 'HTTP.STATUS.503',
    504: 'HTTP.STATUS.504',
});
const HttpLogMessages = Object.freeze({
    NOT_A_RESPONSE: 'An HTTP Response is expected',
    WRONG_STATUS: 'Unexpected HTTP status',
    UNEXPECTED: 'An unexpected error occurred',
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ErrorObject {
}
__decorate([
    deserialize,
    __metadata("design:type", String)
], ErrorObject.prototype, "code", void 0);
__decorate([
    deserialize,
    __metadata("design:type", String)
], ErrorObject.prototype, "source", void 0);
__decorate([
    deserialize,
    __metadata("design:type", Object)
], ErrorObject.prototype, "expects", void 0);
__decorate([
    deserialize,
    __metadata("design:type", String)
], ErrorObject.prototype, "message", void 0);
__decorate([
    deserialize,
    __metadata("design:type", Object)
], ErrorObject.prototype, "details", void 0);
/**
 * Represents the error format of StandIn APIs.
 */
class ErrorResponse {
}
__decorate([
    deserialize,
    __metadata("design:type", String)
], ErrorResponse.prototype, "reference", void 0);
__decorate([
    deserializeAs(ErrorObject),
    __metadata("design:type", Array)
], ErrorResponse.prototype, "errors", void 0);
__decorate([
    deserializeAs(ErrorObject),
    __metadata("design:type", Array)
], ErrorResponse.prototype, "warnings", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @record
 */

/**
 * This service augments \@angular/http with a cache for GET requests.
 *
 * It was created based on what I learned here:
 *
 * @see https://blog.angularindepth.com/rxjs-understanding-the-publish-and-share-operators-16ea2f446635
 * @see https://stackoverflow.com/q/36271899/259237
 */
class CacheableHttpService {
    /**
     * @param {?} delegate
     * @param {?} logger
     */
    constructor(delegate, logger) {
        // empty
        this.delegate = delegate;
        this.logger = logger;
        this.cache = {};
    }
    /**
     * Performs a request with the `post` http method.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    post(url, body, options) {
        return this.delegate.post(url, body, options);
    }
    /**
     * Performs a request with the `put` http method.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    put(url, body, options) {
        return this.delegate.put(url, body, options);
    }
    /**
     * Performs a request with the `delete` http method.
     * @param {?} url
     * @param {?=} options
     * @return {?}
     */
    delete(url, options) {
        return this.delegate.delete(url, options);
    }
    /**
     * Performs a request with the `patch` http method.
     * @param {?} url
     * @param {?} body
     * @param {?=} options
     * @return {?}
     */
    patch(url, body, options) {
        return this.delegate.patch(url, body, options);
    }
    /**
     * Performs a request with the `get` http method.
     * If you pass an expiration time, the Observable will be cached.
     *
     * ### How the cache works
     * - Successive requests to the same URL are served from cache.
     * - Any of these conditions invalidates the cache:
     *   - any request option changes
     *   - the time expires
     *   - the http request fails
     *   - `forceRefresh` is true
     *
     * @param {?} url this address will be the key of the cache
     * @param {?=} options headers, query params etc.
     * @param {?=} expiresIn cache expiration time in seconds. A negative value means no expiration time.
     * @param {?=} forceRefresh if true, this invocation will discard any previous cached value
     * @return {?}
     */
    get(url, options = {}, expiresIn = 0, forceRefresh = false) {
        return of(this.cache[url]).pipe(mergeMap(cache => {
            // TODO this method could be more intelligent. The following examples should be retrieved from cache:
            // - `urlOne = '/address?foo=1&bar=2'` && `urlTwo = '/address?bar=2&foo=1'`
            // - `urlOne = '/foo', optionsOne = { params: bar: 1}` && `urlTwo = '/foo?bar=1', optionsTwo = {}`
            if (cache && forceRefresh)
                cache.expiresIn = 0;
            if (cache && isEqual(options, cache.options) && !this.isExpired(cache.expiresIn)) {
                this.logger.debug('from cache', url);
                return cache.stream;
            }
            else {
                this.logger.debug('caching', url);
                const /** @type {?} */ stream = this.delegate.get(url, options).pipe(shareReplay(1));
                if (expiresIn >= 0)
                    expiresIn = expiresIn * 1000 + new Date().getTime();
                this.cache[url] = { stream, options, expiresIn };
                return stream;
            }
        }), tap$1(() => this.clearStaleEntries()), catchError(error => {
            delete this.cache[url];
            return _throw(error);
        }));
    }
    /**
     * @return {?}
     */
    clearStaleEntries() {
        const /** @type {?} */ oldSize = Object.keys(this.cache).length;
        this.cache = /** @type {?} */ (pickBy(this.cache, (item) => !this.isExpired(item.expiresIn)));
        const /** @type {?} */ newSize = Object.keys(this.cache).length;
        this.logger.debug(`${oldSize - newSize} cache entries removed`);
    }
    /**
     * @param {?} expiresIn
     * @return {?}
     */
    isExpired(expiresIn) {
        const /** @type {?} */ now = new Date().getTime();
        return expiresIn >= 0 && expiresIn < now;
    }
}
CacheableHttpService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
CacheableHttpService.ctorParameters = () => [
    { type: Http, },
    { type: Logger, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This service augments Angular's Http service with Mastercard's headers & error handling.
 *
 * It also adds a "please wait" message during the operation and toasts the result.
 *
 * All those options can be configured per request.
 *
 * The API is similar to Angular's Http class, but first you have to build a request object.
 * Use `HttpReadRequest` for GET & DELETE and `HttpWriteRequest` for POST, PUT & PATCH verbs.
 *
 * The service emits `HttpResponse` for successful requests and `HttpError` otherwise.
 */
class HttpService {
    /**
     * @param {?} delegate
     * @param {?} window
     * @param {?} locale
     * @param {?} logger
     * @param {?} wait
     * @param {?} translate
     * @param {?} toastr
     */
    constructor(delegate, window, locale, logger, wait, translate, toastr) {
        this.delegate = delegate;
        this.logger = logger;
        this.wait = wait;
        this.translate = translate;
        this.toastr = toastr;
        this.window = window;
        locale.getCurrent().subscribe(lang => {
            this.acceptLanguage = lang.replace('-', '_');
            this.logger.debug('Default HTTP request options', this.defaultOptions);
        });
    }
    /**
     * Default HTTP headers that will be sent on each request.
     * @return {?}
     */
    get defaultHeaders() {
        return new Headers({
            'Accept': 'application/json',
            'Content-Type': 'application/json; charset=UTF-8',
            'X-MC-FS-Accept-Language': this.acceptLanguage,
            'X-PRDCT-GRP-ID': this.window.sessionStorage.getItem('prdctGrpId'),
            'X-Customer-ID': this.window.sessionStorage.getItem('customerId'),
        });
    }
    /**
     * Default `RequestOptions` that will be sent on each request.
     * @return {?}
     */
    get defaultOptions() {
        return new RequestOptions({ headers: this.defaultHeaders });
    }
    /**
     * Performs a request with the `get` http method.
     *
     * Emits `HttpResponse` when successful, `HttpError` otherwise.
     * @template RP
     * @param {?} request the configuration object.
     * @return {?}
     */
    get(request) {
        const { url, expiresIn, forceRefresh } = request;
        const /** @type {?} */ options = request.options || this.defaultOptions;
        const /** @type {?} */ response$ = /** @type {?} */ (this.delegate.get(url, options, expiresIn, forceRefresh));
        return this.handle(request, response$);
    }
    /**
     * Performs a request with the `post` http method.
     *
     * Emits `HttpResponse` when successful, `HttpError` otherwise.
     * @template RQ, RP
     * @param {?} request the configuration object.
     * @return {?}
     */
    post(request) {
        const /** @type {?} */ body = this.serialize(request);
        const /** @type {?} */ response$ = this.delegate.post(request.url, body, request.options || this.defaultOptions);
        return this.handle(request, response$);
    }
    /**
     * Performs a request with the `put` http method.
     *
     * Emits `HttpResponse` when successful, `HttpError` otherwise.
     * @template RQ, RP
     * @param {?} request the configuration object.
     * @return {?}
     */
    put(request) {
        const /** @type {?} */ body = this.serialize(request);
        const /** @type {?} */ response$ = this.delegate.put(request.url, body, request.options || this.defaultOptions);
        return this.handle(request, response$);
    }
    /**
     * Performs a request with the `delete` http method.
     *
     * Emits `HttpResponse` when successful, `HttpError` otherwise.
     * @template RP
     * @param {?} request the configuration object.
     * @return {?}
     */
    delete(request) {
        const /** @type {?} */ response$ = /** @type {?} */ (this.delegate.delete(request.url, request.options || this.defaultOptions));
        return this.handle(request, response$);
    }
    /**
     * Performs a request with the `patch` http method.
     *
     * Emits `HttpResponse` when successful, `HttpError` otherwise.
     * @template RQ, RP
     * @param {?} request the configuration object.
     * @return {?}
     */
    patch(request) {
        const /** @type {?} */ body = this.serialize(request);
        const /** @type {?} */ response$ = this.delegate.patch(request.url, body, request.options || this.defaultOptions);
        return this.handle(request, response$);
    }
    /**
     * @template RQ, RP
     * @param {?} request
     * @return {?}
     */
    serialize(request) {
        return request.requestType ? Serialize(request.body, request.requestType) : request.body;
    }
    /**
     * @template RP
     * @param {?} request
     * @param {?} response$
     * @return {?}
     */
    handle(request, response$) {
        let /** @type {?} */ waitMessage;
        response$ = of(request.waitMessage).pipe(
        // maps to the translated wait msg,
        // or to false when there's no wait
        mergeMap(message => {
            if (typeof message === 'string') {
                return this.translate.get(message).pipe(tap$1(translated => {
                    waitMessage = translated;
                    this.logger.debug('adding wait:', translated);
                    this.wait.add(translated);
                }));
            }
            return of(false);
        }),
        // maps to the http response
        mergeMapTo(response$));
        return this.handleResponseStatus(request, response$).pipe(map(response => this.deserialize(request, response)), catchError(error => this.handleError(request, error)), mergeMap(response => this.handleSuccess(request, response)), finalize(() => {
            if (waitMessage) {
                this.logger.debug('removing wait:', waitMessage);
                this.wait.remove(waitMessage);
            }
        }));
    }
    /**
     * @template RP
     * @param {?} request
     * @param {?} response$
     * @return {?}
     */
    handleResponseStatus(request, response$) {
        const /** @type {?} */ errorMsg = request.toastTokens["ERROR"] || HttpDisplayMessages.ERROR;
        const /** @type {?} */ handle = (response) => {
            if (!(response instanceof Response)) {
                const /** @type {?} */ httpError = new HttpError(HttpLogMessages.NOT_A_RESPONSE, response, errorMsg);
                return _throw(httpError);
            }
            const /** @type {?} */ status = response.status;
            const /** @type {?} */ found = request.responseStatus.some(s => s === status);
            if (found)
                return of(response); // success
            // failure
            const /** @type {?} */ wrongStatusMessage = request.toastTokens[status] || request.toastTokens["ERROR"]
                || HttpDisplayMessages[status] || HttpDisplayMessages.ERROR;
            let /** @type {?} */ payload;
            try {
                payload = Deserialize(response.json(), ErrorResponse);
                payload.response = response;
                if (!payload.reference) {
                    payload = response;
                }
            }
            catch (/** @type {?} */ e) {
                payload = response;
            }
            const /** @type {?} */ error = new HttpError(HttpLogMessages.WRONG_STATUS, payload, wrongStatusMessage, status);
            return _throw(error);
        };
        return response$.pipe(catchError(handle), mergeMap(handle));
    }
    /**
     * @template RP
     * @param {?} request
     * @param {?} response
     * @return {?}
     */
    deserialize(request, response) {
        if (request.responseType) {
            const /** @type {?} */ data = Deserialize(response.json(), request.responseType);
            return new HttpResponse(response, data);
        }
        return new HttpResponse(response);
    }
    /**
     * @template RP
     * @param {?} request
     * @param {?} error
     * @return {?}
     */
    handleError(request, error) {
        let /** @type {?} */ result;
        const /** @type {?} */ token = request.toastTokens["ERROR"] || HttpDisplayMessages.ERROR;
        if (error instanceof HttpError) {
            result = error;
        }
        else {
            result = new HttpError(HttpLogMessages.UNEXPECTED, error, token);
        }
        return this.translate.get(result.displayMessage).pipe(mergeMap(translated => {
            this.logger.debug('toasting error:', request.toastOnFailure, translated);
            if (request.toastOnFailure)
                this.toastr.error(translated);
            return _throw(result);
        }));
    }
    /**
     * @template RP
     * @param {?} request
     * @param {?} response
     * @return {?}
     */
    handleSuccess(request, response) {
        const /** @type {?} */ token = request.toastTokens["OK"] || HttpDisplayMessages.OK;
        this.logger.debug('toasting success:', request.toastOnSuccess, token);
        if (request.toastOnSuccess) {
            return this.translate.get(token).pipe(map(translated => {
                this.toastr.success(translated);
                return response;
            }));
        }
        return of(response);
    }
}
HttpService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
HttpService.ctorParameters = () => [
    { type: CacheableHttpService, },
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
    { type: LocaleService, },
    { type: Logger, },
    { type: PleaseWaitService, },
    { type: TranslateService, },
    { type: ToastrService$1, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PleaseWait = Object.freeze({
    DEFAULT_MESSAGE_TOKEN: 'PLEASE_WAIT',
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template RP
 */
class HttpReadRequest {
    /**
     * @param {?} url
     * @param {?=} responseType
     */
    constructor(url, responseType) {
        this.responseStatus = [200, 201, 204];
        this.waitMessage = PleaseWait.DEFAULT_MESSAGE_TOKEN;
        this.toastTokens = HttpDisplayMessages;
        this.toastOnSuccess = true;
        this.toastOnFailure = true;
        this.expiresIn = 0;
        this.forceRefresh = false;
        this.url = url;
        this.responseType = responseType;
    }
    /**
     * Creates a request object for GET or DELETE methods.
     * @see https://github.com/weichx/cerialize
     * @template RP
     * @param {?} url request address
     * @param {?=} responseType class type to deserialize the response body
     * @return {?}
     */
    static create(url, responseType) {
        return new HttpReadRequest(url, responseType);
    }
    /**
     * When provided, the `HttpService` will deserialize the response body (JSON) into
     * an instance of this class type.
     *
     * @see https://github.com/weichx/cerialize
     * @param {?} responseType
     * @return {?}
     */
    withResponseType(responseType) {
        this.responseType = responseType;
        return this;
    }
    /**
     * When provided, the `HttpService` will only accept responses with these status codes.
     * Defaults to `200`, `201` and `204`.
     * @param {?} accepted
     * @param {...?} more
     * @return {?}
     */
    withResponseStatus(accepted, ...more) {
        this.responseStatus = [accepted, ...more];
        return this;
    }
    /**
     * Additional options to be sent to the wrapped `\@angular/http` service.
     * @param {?} options
     * @return {?}
     */
    withOptions(options) {
        this.options = options;
        return this;
    }
    /**
     * Pass a string token to be used as "please wait" message. It'll be translated.
     * Defaults to `PleaseWait.DEFAULT_MESSAGE_TOKEN`.
     *
     * Pass `false` to disable the "please wait" message.
     * @param {?} waitMessage
     * @return {?}
     */
    withWaitMessage(waitMessage) {
        if (waitMessage) {
            this.waitMessage = waitMessage;
        }
        else {
            this.waitMessage = false;
        }
        return this;
    }
    /**
     * Configure the displaying of toast messages on success/failure.
     *
     * @param {?} tokens Map of toast messages for each HTTP response status, plus `OK` and `ERROR`
     * messages. Key is the status code, `'OK'` or `'ERROR'`. Value is the string token (it'll
     * be translated). Pass `false` instead of a map if you don't want any toast at all.
     * Defaults to `HttpDisplayMessages` map.
     *
     * @param {?=} onSuccess Pass `false` to disable toast messages on successful requests.
     * Defaults to `true`.
     *
     * @param {?=} onFailure Pass `false` to disable toast messages on unsuccessful requests.
     * Defaults to `true`.
     * @return {?}
     */
    withToastMessages(tokens, onSuccess, onFailure) {
        if (tokens === false) {
            this.toastOnSuccess = this.toastOnFailure = false;
        }
        else {
            this.toastTokens = tokens;
            if (onSuccess !== undefined)
                this.toastOnSuccess = onSuccess;
            if (onFailure !== undefined)
                this.toastOnFailure = onFailure;
        }
        return this;
    }
    /**
     * Configures the caching of the GET request.
     *
     * ### How the cache works
     * - Successive requests to the same URL are served from cache.
     * - Any of these conditions invalidates the cache:
     *   - any request option changes
     *   - the time expires
     *   - the http request fails
     *   - `forceRefresh` is true
     *
     * @param {?} expiresIn cache expiration time in seconds. A negative value means no expiration time.
     * @param {?=} forceRefresh if true, this invocation will discard any previous cached value
     * @return {?}
     */
    withCache(expiresIn, forceRefresh = false) {
        this.expiresIn = expiresIn;
        this.forceRefresh = forceRefresh;
        return this;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template RQ, RP
 */
class HttpWriteRequest extends HttpReadRequest {
    /**
     * @param {?} url
     * @param {?} body
     * @param {?=} requestType
     * @param {?=} responseType
     */
    constructor(url, body, requestType, responseType) {
        super(url, responseType);
        this.body = body;
        this.requestType = requestType;
    }
    /**
     * Creates a request object for POST, PUT or PATCH methods.
     * @see https://github.com/weichx/cerialize
     * @template RQ, RP
     * @param {?} url request address
     * @param {?} body content to be sent
     * @param {?=} requestType class type to serialize the request body
     * @param {?=} responseType class type to deserialize the response body
     * @return {?}
     */
    static create(url, body, requestType, responseType) {
        return new HttpWriteRequest(url, body, requestType, responseType);
    }
    /**
     * When provided, the `HttpService` will inspect the metadata of this class type to
     * serialize of the request body.
     *
     * @see https://github.com/weichx/cerialize
     * @param {?} requestType
     * @return {?}
     */
    withRequestType(requestType) {
        this.requestType = requestType;
        return this;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MessageKey = Object.freeze({
    GET_ACCESSIBLE_UI_ACTIONS_QUERY: 'GET_ACCESSIBLE_UI_ACTIONS_QUERY',
    GET_ACCESSIBLE_UI_ACTIONS_RESPONSE: 'GET_ACCESSIBLE_UI_ACTIONS_RESPONSE',
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * Service methods to query if the authenticated user is authorized to execute the given actions
 */
class PermissionsService {
    /**
     * @param {?} messageService
     */
    constructor(messageService) {
        // empty
        this.messageService = messageService;
        this.initialized = false;
    }
    /**
     * Initializes the service by querying user's permissions.
     * It should be called at the initialization of the app's root component.
     * @return {?}
     */
    init() {
        if (this.initialized)
            throw new Error('Already initialized');
        this.initialized = true;
        this.stream = this.messageService.get().pipe(filter(me => me.data.message === MessageKey.GET_ACCESSIBLE_UI_ACTIONS_RESPONSE), map(me => /** @type {?} */ (me.data.content)), publishReplay(1), // caches the response
        // caches the response
        refCount());
        this.messageService.post({ message: MessageKey.GET_ACCESSIBLE_UI_ACTIONS_QUERY });
    }
    /**
     * User's authorized actions.
     * @return {?}
     */
    get availableActions() {
        return this.stream;
    }
    /**
     * Checks if the authenticated user has access to the given action.
     * @param {?} actionCode
     * @return {?}
     */
    hasActionCode(actionCode) {
        return this.availableActions.pipe(map((actions) => actions.some(a => a.code === actionCode)));
    }
    /**
     * Checks if the authenticated user has access to at least one of the given actions.
     * @param {...?} actionCodes
     * @return {?}
     */
    hasSome(...actionCodes) {
        return this.availableActions.pipe(map((actions) => actionCodes.some(requested => actions.find(a => a.code === requested) !== undefined)));
    }
    /**
     * Checks if the authenticated user has access to all of the given actions.
     * @param {...?} actionCodes
     * @return {?}
     */
    hasEvery(...actionCodes) {
        return this.availableActions.pipe(map((actions) => actionCodes.every(requested => actions.find(a => a.code === requested) !== undefined)));
    }
}
PermissionsService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PermissionsService.ctorParameters = () => [
    { type: MessageService, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This component displays a static "please wait" modal.
 * Use the `PleaseWaitService` to add/remove messages into it.
 *
 * The modal is automatically shown when a message is added,
 * and closed when there's no more messages left.
 */
class PleaseWaitComponent {
    /**
     * @param {?} service
     * @param {?} logger
     */
    constructor(service, logger) {
        // empty
        this.service = service;
        this.logger = logger;
        this.config = {
            backdrop: 'static',
            show: false,
            keyboard: false,
        };
        this.messages = [];
        this.trackByIndex = trackByIndex;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.service.messagesChange.subscribe(newMessages => {
            if (this.messages.length === 0 && newMessages.length === 1) {
                this.logger.debug('Showing wait message');
                this.modal.show();
            }
            if (newMessages.length === 0) {
                this.logger.debug('Hiding wait message');
                this.modal.hide();
            }
            this.messages = newMessages;
        });
    }
}
PleaseWaitComponent.decorators = [
    { type: Component, args: [{
                selector: 'fc-please-wait',
                template: `<div bsModal #pleaseWait="bs-modal" [config]="config"
     class="modal" tabindex="-1" role="dialog" aria-labelledby="pleaseWaitLabel" aria-hidden="true">
  <div class="modal-dialog please-wait-dialog modal-sm">
    <div class="modal-content">
      <div class="modal-body">
        <ul class="media-list">
          <li class="media">
            <div class="media-left">
              <img class="media-object" width="32px" src="assets/images/wait-blk.gif" alt="">
            </div>
            <div class="media-body">
              <div class="please-wait-heading">{{'PLEASE_WAIT' | translate }}</div>
              <div class="please-wait-messages" *ngFor="let msg of messages; trackBy: trackByIndex" >{{ msg }}</div>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>
`,
                styles: [`.please-wait-dialog{
  padding-top:5px;
  padding-bottom:5px;
  min-height:50px;
  max-width:300px; }
  .please-wait-dialog .modal-body{
    padding-top:16px; }
  .please-wait-dialog .media-body{
    width:auto;
    text-align:left; }
  .please-wait-dialog div.please-wait-heading{
    font-family:Helvetica, Arial, sans-serif;
    font-size:16px;
    font-weight:bold;
    padding-top:5px; }
  .please-wait-dialog div.please-wait-messages{
    font-weight:normal;
    font-family:Helvetica, Arial, sans-serif;
    font-size:13px;
    font-weight:normal;
    padding-top:3px; }
div.fade{
  -webkit-transition:none !important;
  transition:none !important; }
`],
            },] },
];
/** @nocollapse */
PleaseWaitComponent.ctorParameters = () => [
    { type: PleaseWaitService, },
    { type: Logger, },
];
PleaseWaitComponent.propDecorators = {
    "modal": [{ type: ViewChild, args: [ModalDirective,] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MessageKeys = Object.freeze({
    SHOW_CONFIRMATION_DIALOG: 'SHOW_CONFIRMATION_DIALOG',
    CONFIRMATION_DIALOG_OPENED: 'CONFIRMATION_DIALOG_OPENED',
    CONFIRMATION_DIALOG_CLOSED: 'CONFIRMATION_DIALOG_CLOSED',
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Use this service to query/inform whether it's safe to navigate away without losing pending changes.
 * It also contains methods to open the confirmation dialog and get the user response.
 */
class PreventNavigationService {
    /**
     * @param {?} messageService
     * @param {?} window
     */
    constructor(messageService, window) {
        this.messageService = messageService;
        this.storage = (/** @type {?} */ (window)).sessionStorage;
    }
    /**
     * Starts listening to shell messages. Please call this in root component's init method.
     * @return {?}
     */
    start() {
        this.isSafeToQuit = true;
        this.messageService.get().pipe(filter$1(incoming => incoming.data.message === MessageKeys.CONFIRMATION_DIALOG_OPENED)).subscribe(() => {
            this.isSafeToQuit = true;
        });
    }
    /**
     * Flag to indicate whether it's safe to navigate away without losing pending changes.
     * @return {?}
     */
    get isSafeToQuit() {
        return this.storage.getItem('preventNavigation') === '0';
    }
    /**
     * @param {?} safe
     * @return {?}
     */
    set isSafeToQuit(safe) {
        const /** @type {?} */ prevent = !safe;
        this.storage.setItem('preventNavigation', String(+prevent));
    }
    /**
     * Opens the confirmation dialog.
     * @return {?}
     */
    showConfirmationDialog() {
        const /** @type {?} */ message = MessageKeys.SHOW_CONFIRMATION_DIALOG;
        this.isSafeToQuit = true;
        this.messageService.post({ message });
    }
    /**
     * Emits `true` when user confirms, `false` when user cancels.
     * @return {?}
     */
    confirmationDialogClosed() {
        return this.messageService.get().pipe(filter$1(incoming => incoming.data.message === MessageKeys.CONFIRMATION_DIALOG_CLOSED), map$1(incoming => /** @type {?} */ (incoming.data.content.ok)));
    }
}
PreventNavigationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PreventNavigationService.ctorParameters = () => [
    { type: MessageService, },
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const bsModules = [
    AccordionModule,
    AlertModule,
    ButtonsModule,
    CarouselModule,
    CollapseModule,
    ModalModule,
    BsDropdownModule,
    PaginationModule,
    ProgressbarModule,
    RatingModule,
    SortableModule,
    TabsModule,
    TimepickerModule,
    TooltipModule,
    TypeaheadModule,
    PopoverModule,
];
/**
 * @param {?} http
 * @param {?} window
 * @param {?} locale
 * @param {?} logger
 * @param {?} wait
 * @param {?} translate
 * @param {?} toastr
 * @return {?}
 */
function httpFactory(http, window, locale, logger, wait, translate, toastr) {
    return new HttpService(http, window, locale, logger, wait, translate, toastr);
}
/**
 * @return {?}
 */
function xsrfStrategyFactory() {
    return new CookieXSRFStrategy('TFC-XSRF-Token', 'X-TFC-XSRF-Token');
}
/**
 * Collection of utilities for Fraud Center apps.
 */
class FraudCenterCommons {
    /**
     * Use this method in your root module to register our providers.
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: FraudCenterCommons,
            providers: [
                PermissionsService,
                PleaseWaitService,
                ToastrService$1,
                CacheableHttpService,
                PreventNavigationService,
                {
                    provide: HttpService,
                    useFactory: httpFactory,
                    deps: [
                        CacheableHttpService, 'Window', LocaleService, Logger, PleaseWaitService, TranslateService, ToastrService$1
                    ],
                },
                {
                    provide: XSRFStrategy,
                    useFactory: xsrfStrategyFactory
                }
            ],
        };
    }
}
FraudCenterCommons.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MastercardCommons,
                    ...bsModules,
                    ToastrModule,
                    TranslateModule,
                ],
                declarations: [
                    PleaseWaitComponent,
                    DatePickerComponent,
                    DownloadButtonComponent,
                    FcDialogComponent
                ],
                exports: [
                    DatePickerComponent,
                    PleaseWaitComponent,
                    ToastrModule,
                    DownloadButtonComponent,
                    FcDialogComponent
                ],
            },] },
];
/** @nocollapse */
FraudCenterCommons.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { DatePickerComponent, DownloadButtonComponent, DownloadMessages, FcDialogComponent, HttpService, HttpReadRequest, HttpWriteRequest, HttpResponse, HttpError, HttpDisplayMessages, HttpLogMessages, CacheableHttpService, ErrorObject, ErrorResponse, PermissionsService, PleaseWaitService, PleaseWaitComponent, MessageKeys, PreventNavigationService, ToastrService$1 as ToastrService, httpFactory, xsrfStrategyFactory, FraudCenterCommons };
//# sourceMappingURL=mc-fraud-center-commons.js.map
