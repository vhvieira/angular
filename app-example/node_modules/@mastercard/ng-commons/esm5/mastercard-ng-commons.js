import { __spread, __read } from 'tslib';
import { Directive, forwardRef, Input, ElementRef, Renderer2, Injectable, Inject, HostListener, Output, EventEmitter, Optional, Pipe, NgModule } from '@angular/core';
import { NG_VALIDATORS, NgForm, ControlContainer } from '@angular/forms';
import { TranslateLoader } from '@ngx-translate/core';
import { Http } from '@angular/http';
import { map, mergeMap, filter } from 'rxjs/operators';
import { forkJoin } from 'rxjs/observable/forkJoin';
import { ActivatedRoute } from '@angular/router';
import { of } from 'rxjs/observable/of';
import { fromEvent } from 'rxjs/observable/fromEvent';
import * as momentNS from 'moment';
import { CommonModule } from '@angular/common';

var CustomValidatorDirective = /** @class */ (function () {
    function CustomValidatorDirective() {
    }
    CustomValidatorDirective.prototype.validate = function (c) {
        return this.mcCustomValidator(c);
    };
    return CustomValidatorDirective;
}());
CustomValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcCustomValidator][ngModel]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return CustomValidatorDirective; }), multi: true }
                ]
            },] },
];
CustomValidatorDirective.ctorParameters = function () { return []; };
CustomValidatorDirective.propDecorators = {
    "mcCustomValidator": [{ type: Input },],
};
var ShowErrorIconDirective = /** @class */ (function () {
    function ShowErrorIconDirective(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hasError = false;
        this.errorIconElement = this.renderer.createElement("span");
        this.divElement = this.renderer.createElement("div");
    }
    ShowErrorIconDirective.prototype.ngOnInit = function () {
        var parent = this.el.nativeElement.parentNode;
        this.renderer.addClass(this.errorIconElement, "sprite");
        this.renderer.addClass(this.errorIconElement, "icon-error");
        this.renderer.addClass(this.divElement, "input-icon-error-wrapper");
        this.renderer.insertBefore(parent, this.divElement, this.el.nativeElement);
        this.renderer.removeChild(parent, this.el.nativeElement);
        this.renderer.appendChild(this.divElement, this.el.nativeElement);
    };
    ShowErrorIconDirective.prototype.ngOnChanges = function () {
        if (this.mcShowErrorIcon) {
            this.addError();
        }
        else {
            this.removeError();
        }
    };
    ShowErrorIconDirective.prototype.addError = function () {
        this.renderer.appendChild(this.divElement, this.errorIconElement);
        this.hasError = true;
    };
    ShowErrorIconDirective.prototype.removeError = function () {
        if (this.hasError) {
            this.renderer.removeChild(this.divElement, this.errorIconElement);
            this.hasError = false;
        }
    };
    return ShowErrorIconDirective;
}());
ShowErrorIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcShowErrorIcon]'
            },] },
];
ShowErrorIconDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
]; };
ShowErrorIconDirective.propDecorators = {
    "mcShowErrorIcon": [{ type: Input },],
};
function formFactory(form) {
    return form;
}
var ProvideParentFormDirective = /** @class */ (function () {
    function ProvideParentFormDirective() {
    }
    return ProvideParentFormDirective;
}());
ProvideParentFormDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcProvideParentForm]',
                providers: [
                    {
                        provide: ControlContainer,
                        useFactory: formFactory,
                        deps: [NgForm]
                    }
                ]
            },] },
];
ProvideParentFormDirective.ctorParameters = function () { return []; };
var LogLevel = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
};
LogLevel[LogLevel.DEBUG] = "DEBUG";
LogLevel[LogLevel.INFO] = "INFO";
LogLevel[LogLevel.WARN] = "WARN";
LogLevel[LogLevel.ERROR] = "ERROR";
var logLevel = LogLevel.INFO;
function getDefaultLogLevel() {
    return logLevel;
}
function setDefaultLogLevel(level) {
    logLevel = level;
}
var Logger = /** @class */ (function () {
    function Logger(level) {
        this.level = level;
    }
    Logger.prototype.error = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (this.level <= LogLevel.ERROR)
            console.error.apply(console, __spread([message], optionalParams));
    };
    Logger.prototype.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (this.level <= LogLevel.WARN)
            console.warn.apply(console, __spread([message], optionalParams));
    };
    Logger.prototype.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (this.level <= LogLevel.INFO)
            console.info.apply(console, __spread([message], optionalParams));
    };
    Logger.prototype.debug = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (this.level <= LogLevel.DEBUG)
            console.log.apply(console, __spread([message], optionalParams));
    };
    return Logger;
}());
Logger.decorators = [
    { type: Injectable },
];
Logger.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: ['LogLevel',] },] },
]; };
var StrictPatternDirective = /** @class */ (function () {
    function StrictPatternDirective(el, logger) {
        this.el = el;
        this.logger = logger;
        this.ngModelChange = new EventEmitter();
        this.logger.debug('Strict Pattern Directive built');
    }
    StrictPatternDirective.prototype.onChange = function (e) {
        if (this.event) {
            if (this.event === 'change') {
                this.validation(e);
            }
            else {
                this.logger.warn('Only change event is allowed.');
            }
        }
    };
    StrictPatternDirective.prototype.onInput = function (e) {
        if (!this.event) {
            this.validation(e);
        }
    };
    StrictPatternDirective.prototype.validation = function (e) {
        var newValue = e.target.value;
        var pattern = this.el.nativeElement.attributes.getNamedItem('pattern').value;
        var reg = new RegExp(pattern);
        if (reg.test(newValue) || newValue === '') {
            e.target.previousValue = e.target.value;
            this.logger.debug("Pattern ok. Value = \"" + e.target.value + "\"");
        }
        else {
            e.target.value = e.target.previousValue || '';
            this.ngModelChange.emit(e.target.value);
            this.logger.debug("Pattern ko. Restoring value = \"" + e.target.value + "\"");
        }
    };
    return StrictPatternDirective;
}());
StrictPatternDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[type=text][mcStrict][pattern]'
            },] },
];
StrictPatternDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Logger, },
]; };
StrictPatternDirective.propDecorators = {
    "event": [{ type: Input, args: ['mcStrict',] },],
    "ngModelChange": [{ type: Output },],
    "onChange": [{ type: HostListener, args: ['change', ['$event'],] },],
    "onInput": [{ type: HostListener, args: ['input', ['$event'],] },],
};
var TrimDirective = /** @class */ (function () {
    function TrimDirective(element) {
        this.ngModelChange = new EventEmitter();
        this.element = element.nativeElement;
    }
    TrimDirective.prototype.onChange = function (value) {
        value = value.trim();
        this.element.value = value;
        this.ngModelChange.emit(value);
    };
    return TrimDirective;
}());
TrimDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[mcTrim],textarea[mcTrim]'
            },] },
];
TrimDirective.ctorParameters = function () { return [
    { type: ElementRef, },
]; };
TrimDirective.propDecorators = {
    "ngModelChange": [{ type: Output },],
    "onChange": [{ type: HostListener, args: ['change', ['$event.target.value'],] },],
};
function trackByIndex(i) {
    return i;
}
function searchValidator() {
    return function (c) {
        var pattern = /[\?\'\"\<\>\/]+/g;
        var value = String(c.value || '');
        return pattern.test(value) ? { invalidCharError: true } : null;
    };
}
function makeConfig(factoryFn) {
    return {
        loader: {
            provide: TranslateLoader,
            useFactory: factoryFn,
            deps: [Http],
        },
    };
}
var TranslateStaticLoader = /** @class */ (function () {
    function TranslateStaticLoader(http, prefix, suffix, apps) {
        if (prefix === void 0) { prefix = 'i18n'; }
        if (suffix === void 0) { suffix = '.json'; }
        this.http = http;
        this.prefix = prefix;
        this.suffix = suffix;
        this.apps = apps;
    }
    TranslateStaticLoader.prototype.getTranslation = function (lang) {
        var _this = this;
        var requests = [];
        var prefix = this.prefix;
        var suffix = this.suffix;
        requests.push(this.http.get(prefix + '/' + lang + '/' + lang + suffix));
        this.apps.forEach(function (appName) {
            var url = prefix + '/' + lang + '/' + appName + '_' + lang + suffix;
            requests.push(_this.http.get(url));
        });
        return forkJoin.apply(void 0, __spread(requests)).pipe(map(function (responses) {
            var first = responses.shift();
            var combined = first && first.json();
            var counter = 0;
            responses.forEach(function (res) {
                var translates = res.json();
                var appName = _this.apps[counter];
                combined[appName.toUpperCase()] = translates[appName.toUpperCase()];
                counter++;
            });
            return combined;
        }));
    };
    return TranslateStaticLoader;
}());
var LOCALE = Object.freeze({
    ENGLISH: 'en-US',
    SPANISH: 'es-CO',
    PORTUGUESE: 'pt-BR',
    get DEFAULT() { return this.ENGLISH; },
});
var LOCALE_STORAGE_KEY = 'locale';
var LOCALE_QUERY_PARAM = 'locale';
var LocaleService = /** @class */ (function () {
    function LocaleService(window, activated) {
        this.activated = activated;
        this.window = window;
    }
    LocaleService.prototype.getCurrent = function () {
        var _this = this;
        return of(LOCALE.DEFAULT).pipe(map(function (defaultLocale) {
            var sessionLocale = _this.window.sessionStorage.getItem(LOCALE_STORAGE_KEY);
            return sessionLocale || defaultLocale;
        }), mergeMap(function (locale) {
            if (_this.activated) {
                return _this.activated.queryParams.pipe(map(function (params) {
                    return params[LOCALE_QUERY_PARAM] || locale;
                }));
            }
            else {
                return of(locale);
            }
        }));
    };
    return LocaleService;
}());
LocaleService.decorators = [
    { type: Injectable },
];
LocaleService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
    { type: ActivatedRoute, decorators: [{ type: Optional },] },
]; };
function filterSameOrigin(window) {
    return function (msg) { return msg.origin === window.location.origin; };
}
function filterSameWindow(source) {
    return function (msg) { return msg.source === source; };
}
var MessageService = /** @class */ (function () {
    function MessageService(window) {
        this.window = window;
        this.message$ = fromEvent(this.window, 'message').pipe(filter(filterSameOrigin(window)));
    }
    MessageService.prototype.get = function (source) {
        if (source === void 0) { source = this.window.parent; }
        var fn = filterSameWindow(source);
        return this.message$.pipe(filter(fn));
    };
    MessageService.prototype.post = function (message, target) {
        if (target === void 0) { target = this.window.parent; }
        var sameOrigin = this.window.location.origin;
        target.postMessage(message, sameOrigin);
    };
    return MessageService;
}());
MessageService.decorators = [
    { type: Injectable },
];
MessageService.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
]; };
var moment = momentNS;
var DateFormatPipe = /** @class */ (function () {
    function DateFormatPipe() {
    }
    DateFormatPipe.prototype.transform = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _a = __read(args, 1), format = _a[0];
        if (!format) {
            format = 'DD-MMM-YYYY hh:mm A';
        }
        return moment(value).format(format);
    };
    return DateFormatPipe;
}());
DateFormatPipe.decorators = [
    { type: Pipe, args: [{
                name: 'dateFormat'
            },] },
];
DateFormatPipe.ctorParameters = function () { return []; };
var RequiredFieldLabelPipe = /** @class */ (function () {
    function RequiredFieldLabelPipe() {
        this.mark = "<span class='required'>*</span>";
    }
    RequiredFieldLabelPipe.prototype.transform = function (value, field) {
        var visible = typeof field === 'undefined' || field.required;
        return value && visible ? value + this.mark : value;
    };
    return RequiredFieldLabelPipe;
}());
RequiredFieldLabelPipe.decorators = [
    { type: Pipe, args: [{ name: 'requiredFieldLabel' },] },
];
RequiredFieldLabelPipe.ctorParameters = function () { return []; };
function getWindow() { return window; }
var declarations = [
    CustomValidatorDirective,
    TrimDirective,
    RequiredFieldLabelPipe,
    ProvideParentFormDirective,
    StrictPatternDirective,
    ShowErrorIconDirective,
    DateFormatPipe,
];
var MastercardCommons = /** @class */ (function () {
    function MastercardCommons() {
    }
    MastercardCommons.forRoot = function () {
        return {
            ngModule: MastercardCommons,
            providers: [
                Logger,
                MessageService,
                LocaleService,
                { provide: 'LogLevel', useFactory: getDefaultLogLevel },
                { provide: 'Window', useFactory: getWindow },
            ],
        };
    };
    return MastercardCommons;
}());
MastercardCommons.decorators = [
    { type: NgModule, args: [{
                declarations: declarations,
                imports: [CommonModule],
                exports: __spread(declarations),
            },] },
];
MastercardCommons.ctorParameters = function () { return []; };

export { CustomValidatorDirective, ShowErrorIconDirective, formFactory, ProvideParentFormDirective, StrictPatternDirective, TrimDirective, trackByIndex, searchValidator, makeConfig, TranslateStaticLoader, LocaleService, LOCALE, LOCALE_STORAGE_KEY, LOCALE_QUERY_PARAM, LogLevel, getDefaultLogLevel, setDefaultLogLevel, Logger, filterSameOrigin, filterSameWindow, MessageService, getWindow, MastercardCommons, DateFormatPipe as ɵb, RequiredFieldLabelPipe as ɵa };
//# sourceMappingURL=mastercard-ng-commons.js.map
