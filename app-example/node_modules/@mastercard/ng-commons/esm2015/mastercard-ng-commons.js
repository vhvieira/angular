import { Directive, forwardRef, Input, ElementRef, Renderer2, Injectable, Inject, HostListener, Output, EventEmitter, Optional, Pipe, NgModule } from '@angular/core';
import { NG_VALIDATORS, NgForm, ControlContainer } from '@angular/forms';
import { TranslateLoader } from '@ngx-translate/core';
import { Http } from '@angular/http';
import { map, mergeMap, filter } from 'rxjs/operators';
import { forkJoin } from 'rxjs/observable/forkJoin';
import { ActivatedRoute } from '@angular/router';
import { of } from 'rxjs/observable/of';
import { fromEvent } from 'rxjs/observable/fromEvent';
import * as momentNS from 'moment';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This directive lets you add custom validator functions to your template based forms.
 * Angular will then use your function to mark the field as valid/invalid.
 *
 * ### Example:
 * ```
 * // component.html
 * <input #myField="ngModel" [(ngModel)]='whatever'
 *   [mcCustomValidator]="myCustomValidator()" ... />
 * <div *ngIf="myField.errors.myCustomErr">
 *   {{ myField.errors.myCustomErr }}
 * </div>
 *
 * // component.ts
 * import { AbstractControl, ValidatorFn } from '\@angular/forms';
 * // (...)
 * myCustomValidator(): ValidatorFn {
 *   return (c: AbstractControl) => {
 *     return c.value === 'foo' || c.value === 'bar'
 *       ? null // any non null value is an error
 *       : { myCustomErr: 'Value must be foo or bar' };
 *   }
 * }
 * ```
 */
class CustomValidatorDirective {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.mcCustomValidator(c);
    }
}
CustomValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcCustomValidator][ngModel]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(() => CustomValidatorDirective), multi: true }
                ]
            },] },
];
/** @nocollapse */
CustomValidatorDirective.ctorParameters = () => [];
CustomValidatorDirective.propDecorators = {
    "mcCustomValidator": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ShowErrorIconDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hasError = false;
        this.errorIconElement = this.renderer.createElement(`span`);
        this.divElement = this.renderer.createElement(`div`);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const /** @type {?} */ parent = this.el.nativeElement.parentNode;
        this.renderer.addClass(this.errorIconElement, `sprite`);
        this.renderer.addClass(this.errorIconElement, `icon-error`);
        this.renderer.addClass(this.divElement, `input-icon-error-wrapper`);
        this.renderer.insertBefore(parent, this.divElement, this.el.nativeElement);
        this.renderer.removeChild(parent, this.el.nativeElement);
        this.renderer.appendChild(this.divElement, this.el.nativeElement);
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.mcShowErrorIcon) {
            this.addError();
        }
        else {
            this.removeError();
        }
    }
    /**
     * @return {?}
     */
    addError() {
        this.renderer.appendChild(this.divElement, this.errorIconElement);
        this.hasError = true;
    }
    /**
     * @return {?}
     */
    removeError() {
        if (this.hasError) {
            this.renderer.removeChild(this.divElement, this.errorIconElement);
            this.hasError = false;
        }
    }
}
ShowErrorIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcShowErrorIcon]'
            },] },
];
/** @nocollapse */
ShowErrorIconDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
ShowErrorIconDirective.propDecorators = {
    "mcShowErrorIcon": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} form
 * @return {?}
 */
function formFactory(form) {
    return form;
}
/**
 * This directive provides a parent form to a child component
 * ### Example:
 * ```html
 * <!-- parent component -->
 * <form #parentForm="ngForm">
 *   <label>Parent Input:</label>
 *   <input [(ngModel)]="parentInput" name="parentInput" />
 *   <child-component></child-component>
 *  (...)
 *
 * <!-- child component -->
 *  <div style="color: red;" mcProvideParentForm>
 *    <label>Child Input:</label>
 *    <input [(ngModel)]="childInput" name="childInput" />
 *
 * ```
 * @see https://github.com/angular/angular/issues/9600#issuecomment-326865141
 */
class ProvideParentFormDirective {
}
ProvideParentFormDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mcProvideParentForm]',
                providers: [
                    {
                        provide: ControlContainer,
                        useFactory: formFactory,
                        deps: [NgForm]
                    }
                ]
            },] },
];
/** @nocollapse */
ProvideParentFormDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const LogLevel = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
};
LogLevel[LogLevel.DEBUG] = "DEBUG";
LogLevel[LogLevel.INFO] = "INFO";
LogLevel[LogLevel.WARN] = "WARN";
LogLevel[LogLevel.ERROR] = "ERROR";
/**
 * Default log level for the Logger service.
 */
let logLevel = LogLevel.INFO;
/**
 * Factory fn for the LogLevel provider.
 * @return {?}
 */
function getDefaultLogLevel() {
    return logLevel;
}
/**
 * Changes the default LogLevel for the Logger service.
 * @param {?} level new level.
 * @return {?}
 */
function setDefaultLogLevel(level) {
    logLevel = level;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Logs messages with different levels of severity.
 */
class Logger {
    /**
     * @param {?} level
     */
    constructor(level) {
        this.level = level;
    }
    /**
     * Logs an error message.
     *
     * Each argument is concatenated into a space-delimited string.
     * @param {?} message the value to be logged.
     * @param {...?} optionalParams you can pass as many values as you want.
     * @return {?}
     */
    error(message, ...optionalParams) {
        if (this.level <= LogLevel.ERROR)
            console.error(message, ...optionalParams);
    }
    /**
     * Logs a warn message.
     *
     * Each argument is concatenated into a space-delimited string.
     * @param {?} message the value to be logged.
     * @param {...?} optionalParams you can pass as many values as you want.
     * @return {?}
     */
    warn(message, ...optionalParams) {
        if (this.level <= LogLevel.WARN)
            console.warn(message, ...optionalParams);
    }
    /**
     * Logs an info message.
     *
     * Each argument is concatenated into a space-delimited string.
     * @param {?} message the value to be logged.
     * @param {...?} optionalParams you can pass as many values as you want.
     * @return {?}
     */
    info(message, ...optionalParams) {
        if (this.level <= LogLevel.INFO)
            console.info(message, ...optionalParams);
    }
    /**
     * Logs a debug message.
     *
     * Each argument is concatenated into a space-delimited string.
     * @param {?} message the value to be logged.
     * @param {...?} optionalParams you can pass as many values as you want.
     * @return {?}
     */
    debug(message, ...optionalParams) {
        if (this.level <= LogLevel.DEBUG)
            console.log(message, ...optionalParams);
    }
}
Logger.decorators = [
    { type: Injectable },
];
/** @nocollapse */
Logger.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['LogLevel',] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This directive ensures that the input field accepts only values that matches the `[pattern]` regex.
 * If the user tries to input an invalid value, the directive will deny the value change.
 * The validation occurs on `input` or `change` event.
 *
 * ### Example
 * ```html
 * <input type="text" mcStrict pattern="^[0-9]+$" />
 * <input type="text" mcStrict="change" pattern="^[a-zA-Z]+$" />
 * ```
 */
class StrictPatternDirective {
    /**
     * @param {?} el
     * @param {?} logger
     */
    constructor(el, logger) {
        this.el = el;
        this.logger = logger;
        this.ngModelChange = new EventEmitter();
        this.logger.debug('Strict Pattern Directive built');
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onChange(e) {
        if (this.event) {
            if (this.event === 'change') {
                this.validation(e);
            }
            else {
                this.logger.warn('Only change event is allowed.');
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onInput(e) {
        if (!this.event) {
            this.validation(e);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    validation(e) {
        const /** @type {?} */ newValue = e.target.value;
        const /** @type {?} */ pattern = this.el.nativeElement.attributes.getNamedItem('pattern').value;
        const /** @type {?} */ reg = new RegExp(pattern);
        if (reg.test(newValue) || newValue === '') {
            e.target.previousValue = e.target.value;
            this.logger.debug(`Pattern ok. Value = "${e.target.value}"`);
        }
        else {
            e.target.value = e.target.previousValue || '';
            this.ngModelChange.emit(e.target.value);
            this.logger.debug(`Pattern ko. Restoring value = "${e.target.value}"`);
        }
    }
}
StrictPatternDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[type=text][mcStrict][pattern]'
            },] },
];
/** @nocollapse */
StrictPatternDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Logger, },
];
StrictPatternDirective.propDecorators = {
    "event": [{ type: Input, args: ['mcStrict',] },],
    "ngModelChange": [{ type: Output },],
    "onChange": [{ type: HostListener, args: ['change', ['$event'],] },],
    "onInput": [{ type: HostListener, args: ['input', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Trims the field value & the model value on change.
 *
 * Works with input & textarea.
 *
 * #### Example:
 * ```html
 * <input type="text" mcTrim [(ngModel)]=...
 * ```
 */
class TrimDirective {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.ngModelChange = new EventEmitter();
        this.element = element.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChange(value) {
        value = value.trim();
        this.element.value = value;
        this.ngModelChange.emit(value);
    }
}
TrimDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[mcTrim],textarea[mcTrim]'
            },] },
];
/** @nocollapse */
TrimDirective.ctorParameters = () => [
    { type: ElementRef, },
];
TrimDirective.propDecorators = {
    "ngModelChange": [{ type: Output },],
    "onChange": [{ type: HostListener, args: ['change', ['$event.target.value'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// shared common functions
// NgForOf trackers -----------------------------------------------------------
// To customize the default tracking algorithm, NgForOf supports trackBy option.
// trackBy takes a function which has two arguments: index and item.
// If trackBy is given, Angular tracks changes by the return value of the function.
/**
 * Detects a change when an index changes.
 *
 * ```html
 * <li *ngFor="let msg of messages; trackBy: trackByIndex">...
 * ```
 * @see https://angular.io/api/common/NgForOf
 * @param {?} i
 * @return {?}
 */
function trackByIndex(i) {
    return i;
}
// -----------------------------------------------------------------------------

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Validator that forbids controls values to have the following characters:
 * ? ' " < > /
 * @return {?}
 */
function searchValidator() {
    return (c) => {
        const /** @type {?} */ pattern = /[\?\'\"\<\>\/]+/g;
        const /** @type {?} */ value = String(c.value || '');
        return pattern.test(value) ? { invalidCharError: true } : null;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} factoryFn
 * @return {?}
 */
function makeConfig(factoryFn) {
    return {
        loader: {
            provide: TranslateLoader,
            useFactory: factoryFn,
            deps: [Http],
        },
    };
}
class TranslateStaticLoader {
    /**
     * @param {?} http
     * @param {?=} prefix
     * @param {?=} suffix
     * @param {?=} apps
     */
    constructor(http, prefix = 'i18n', suffix = '.json', apps) {
        // empty
        this.http = http;
        this.prefix = prefix;
        this.suffix = suffix;
        this.apps = apps;
    }
    /**
     * Gets the translations from the server
     * @param {?} lang
     * @return {?}
     */
    getTranslation(lang) {
        const /** @type {?} */ requests = [];
        const /** @type {?} */ prefix = this.prefix;
        const /** @type {?} */ suffix = this.suffix;
        // Load global
        requests.push(this.http.get(prefix + '/' + lang + '/' + lang + suffix));
        // Load app-specific i18n files
        this.apps.forEach((appName) => {
            const /** @type {?} */ url = prefix + '/' + lang + '/' + appName + '_' + lang + suffix;
            requests.push(this.http.get(url));
        });
        return forkJoin(...requests).pipe(map(responses => {
            const /** @type {?} */ first = responses.shift();
            const /** @type {?} */ combined = first && first.json();
            let /** @type {?} */ counter = 0;
            responses.forEach((res) => {
                const /** @type {?} */ translates = res.json();
                const /** @type {?} */ appName = this.apps[counter];
                combined[appName.toUpperCase()] = translates[appName.toUpperCase()];
                counter++;
            });
            return combined;
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const LOCALE = Object.freeze({
    ENGLISH: 'en-US',
    SPANISH: 'es-CO',
    PORTUGUESE: 'pt-BR',
    /**
     * @return {?}
     */
    get DEFAULT() { return this.ENGLISH; },
});
const LOCALE_STORAGE_KEY = 'locale';
const LOCALE_QUERY_PARAM = 'locale';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This service provides the current locale.
 * It looks for the locale on:
 * 1. a URL query param;
 * 1. a session storage key;
 * 1. Fallback to the default "en-US".
 */
class LocaleService {
    /**
     * @param {?} window
     * @param {?} activated
     */
    constructor(window, activated) {
        this.activated = activated;
        this.window = window;
    }
    /**
     * Retrieves the current locale.
     * This stream re-emits the locale when the query param changes.
     * @return {?}
     */
    getCurrent() {
        return of(LOCALE.DEFAULT).pipe(
        // overrides with the locale on session storage
        map((defaultLocale) => {
            const /** @type {?} */ sessionLocale = this.window.sessionStorage.getItem(LOCALE_STORAGE_KEY);
            return sessionLocale || defaultLocale;
        }),
        // overrides with the locale on query param
        mergeMap((locale) => {
            if (this.activated) {
                return this.activated.queryParams.pipe(map(params => {
                    return params[LOCALE_QUERY_PARAM] || locale;
                }));
            }
            else {
                return of(locale);
            }
        }));
    }
}
LocaleService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LocaleService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
    { type: ActivatedRoute, decorators: [{ type: Optional },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} window
 * @return {?}
 */
function filterSameOrigin(window) {
    return (msg) => msg.origin === window.location.origin;
}
/**
 * @param {?} source
 * @return {?}
 */
function filterSameWindow(source) {
    return (msg) => msg.source === source;
}
/**
 * This service allows the client to send/receive message events
 * to/from other windows as long as both windows share the same origin.
 */
class MessageService {
    /**
     * @param {?} window
     */
    constructor(window) {
        this.window = window;
        this.message$ = fromEvent(this.window, 'message').pipe(filter(filterSameOrigin(window)));
    }
    /**
     * Provides a stream of messages coming from the given window.
     *
     * @param {?=} source filter messages that come from this window. Defaults to the parent window.
     * @return {?}
     */
    get(source = this.window.parent) {
        const /** @type {?} */ fn = filterSameWindow(source);
        return this.message$.pipe(filter(fn));
    }
    /**
     * Sends a message to the given target window.
     *
     * @param {?} message a value that will be serialized and sent as a message.
     * @param {?=} target the message will be sent to this window. Defaults to the parent window.
     * @return {?}
     */
    post(message, target = this.window.parent) {
        const /** @type {?} */ sameOrigin = this.window.location.origin;
        target.postMessage(message, sameOrigin);
    }
}
MessageService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
MessageService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['Window',] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment = momentNS;
/**
 * Transforms a `Date` or a `Moment` object into a string with the given format.
 * When no format is provided, defaults to `'DD-MMM-YYYY hh:mm A'`.
 *
 * #### Example:
 * ```html
 * <span>{{ myDate | dateFormat }}</span>
 * <span>{{ myDate2 | dateFormat:'YYYY-MM-DD' }}</span>
 * ```
 *
 * See {\@link https://momentjs.com/docs/ } for more info.
 */
class DateFormatPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        let [format] = args;
        if (!format) {
            format = 'DD-MMM-YYYY hh:mm A';
        }
        return moment(value).format(format);
    }
}
DateFormatPipe.decorators = [
    { type: Pipe, args: [{
                name: 'dateFormat'
            },] },
];
/** @nocollapse */
DateFormatPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Appends the `*` char on the field label, if necessary.
 *
 * #### Example:
 * ```html
 * <label for="myField"
 *   [innerHTML]="'My Field' | requiredFieldLabel:myField"
 * ></label>
 * <input #myField id="myField" ...
 * ```
 */
class RequiredFieldLabelPipe {
    constructor() {
        this.mark = "<span class='required'>*</span>";
    }
    /**
     * @param {?} value the span will be appended to this value
     * @param {?=} field appends the span whe matching field is not provided or when it's a required field.
     * @return {?}
     */
    transform(value, field) {
        const /** @type {?} */ visible = typeof field === 'undefined' || field.required;
        return value && visible ? value + this.mark : value;
    }
}
RequiredFieldLabelPipe.decorators = [
    { type: Pipe, args: [{ name: 'requiredFieldLabel' },] },
];
/** @nocollapse */
RequiredFieldLabelPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function getWindow() { return window; }
const declarations = [
    CustomValidatorDirective,
    TrimDirective,
    RequiredFieldLabelPipe,
    ProvideParentFormDirective,
    StrictPatternDirective,
    ShowErrorIconDirective,
    DateFormatPipe,
];
/**
 * Mastercard's Utilities for Angular
 */
class MastercardCommons {
    /**
     * Use this method in your root module to register our providers.
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: MastercardCommons,
            providers: [
                Logger,
                MessageService,
                LocaleService,
                { provide: 'LogLevel', useFactory: getDefaultLogLevel },
                { provide: 'Window', useFactory: getWindow },
            ],
        };
    }
}
MastercardCommons.decorators = [
    { type: NgModule, args: [{
                declarations,
                imports: [CommonModule],
                exports: [...declarations],
            },] },
];
/** @nocollapse */
MastercardCommons.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { CustomValidatorDirective, ShowErrorIconDirective, formFactory, ProvideParentFormDirective, StrictPatternDirective, TrimDirective, trackByIndex, searchValidator, makeConfig, TranslateStaticLoader, LocaleService, LOCALE, LOCALE_STORAGE_KEY, LOCALE_QUERY_PARAM, LogLevel, getDefaultLogLevel, setDefaultLogLevel, Logger, filterSameOrigin, filterSameWindow, MessageService, getWindow, MastercardCommons, DateFormatPipe as ɵb, RequiredFieldLabelPipe as ɵa };
//# sourceMappingURL=mastercard-ng-commons.js.map
